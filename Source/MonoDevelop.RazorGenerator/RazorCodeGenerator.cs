using RazorGenerator.Core;using MonoDevelop.Ide.CustomTools;using MonoDevelop.Core;using MonoDevelop.Projects;using System;using System.CodeDom.Compiler;using MonoDevelop.DesignerSupport;namespace MonoDevelop.RazorGenerator{	/// <summary>	/// Razor code generator.	/// </summary>	public class RazorCodeGenerator: ISingleFileCustomTool	{		/// <summary>		/// Generate the specified monitor, file and result.		/// </summary>		/// <param name="monitor">Monitor.</param>		/// <param name="file">File.</param>		/// <param name="result">Result.</param>		public IAsyncOperation Generate(IProgressMonitor monitor, ProjectFile file, SingleFileCustomToolResult result)		{			return new ThreadAsyncOperation(() =>			{				try				{					GenerateInternal(monitor, file, result);				}				catch(Exception ex)				{					result.UnhandledException = ex;				}			}, result);		}		private void GenerateInternal(IProgressMonitor monitor, ProjectFile file, SingleFileCustomToolResult result)		{			DotNetProject project = file.Project as DotNetProject;			if(project == null || project.LanguageName != "C#")			{				string message = "Razor views are only supported in C# projects.";				result.Errors.Add(new CompilerError(file.Name, -1, -1, null, message));				monitor.Log.WriteLine(message);				return;			}			FilePath defaultOutputName = file.FilePath.ChangeExtension(".generated.cs");			string projectDirectory = project.BaseDirectory;			string projectRelativePath = file.FilePath.ToString().Substring(projectDirectory.Length);			using(HostManager hostManager = new HostManager(projectDirectory))			{				IRazorHost host = hostManager.CreateHost(file.FilePath.FullPath, projectRelativePath);				host.DefaultNamespace = GetNamespaceHint(file, defaultOutputName);				host.Error += (o, eventArgs) =>	CreateCompilerError(file, result, eventArgs);				string code = host.GenerateCode();				CodeBehindWriter writer = new CodeBehindWriter();				writer.WriteFile(defaultOutputName, code);				writer.WriteOpenFiles();				result.GeneratedFilePath = defaultOutputName;			}		}		/// <summary>		/// Creates the compiler error.		/// </summary>		/// <param name="file">File.</param>		/// <param name="result">Result.</param>		/// <param name="eventArgs">Event arguments.</param>		private static void CreateCompilerError(ProjectFile file, SingleFileCustomToolResult result, GeneratorErrorEventArgs eventArgs)		{			result.Errors.Add(new CompilerError { 				FileName = file.Name, 				ErrorText = eventArgs.ErrorMessage, 				ErrorNumber = eventArgs.ErorrCode.ToString(), 				Line = (int)eventArgs.LineNumber, 				Column = (int)eventArgs.ColumnNumber, 				IsWarning = false, 			});		}		/// <summary>		/// Gets the namespace hint.		/// </summary>		/// <returns>The namespace hint.</returns>		/// <param name="file">File.</param>		/// <param name="outputFile">Output file.</param>		private static string GetNamespaceHint(ProjectFile file, string outputFile)		{			string ns = file.CustomToolNamespace;			if(string.IsNullOrEmpty(ns) && !string.IsNullOrEmpty(outputFile))			{				DotNetProject project = ((DotNetProject)file.Project);				ns = project.GetDefaultNamespace(outputFile);			}			return ns;		}	}}